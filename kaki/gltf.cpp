//
// Created by felix on 16/01/2022.
//

#include "gltf.h"
#include "cgltf.h"
#include <cstdio>
#include <span>
#include "vk.h"

namespace kaki {

    static std::pair<VkBuffer, VmaAllocation> loadGltfBuffer(const VkGlobals& vk, const cgltf_buffer_view& buffer_view) {

        VkBufferCreateInfo bufferInfo = {};
        bufferInfo.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;
        bufferInfo.size = buffer_view.size;
        bufferInfo.usage = VK_BUFFER_USAGE_VERTEX_BUFFER_BIT | VK_BUFFER_USAGE_INDEX_BUFFER_BIT;

        VmaAllocationCreateInfo vmaAllocInfo = {};
        vmaAllocInfo.usage = VMA_MEMORY_USAGE_CPU_TO_GPU; // TODO use a staging buffer

        VkBuffer buffer;
        VmaAllocation alloc;

        vmaCreateBuffer(vk.allocator, &bufferInfo, &vmaAllocInfo,
                            &buffer,
                            &alloc,
                            nullptr);

        void* bufferData;
        vmaMapMemory(vk.allocator, alloc, &bufferData);
        memcpy(bufferData, (std::byte*)buffer_view.buffer->data + buffer_view.offset, buffer_view.size);
        vmaUnmapMemory(vk.allocator, alloc);

        return {buffer, alloc};
    }


    static Mesh::Primitive loadGltfPrimitive(cgltf_primitive &primitive) {
        assert(primitive.type == cgltf_primitive_type_triangles);

        Mesh::Primitive prim{};
        prim.indexCount = primitive.indices->count;
        prim.indexOffset = primitive.indices->offset / primitive.indices->stride;
        prim.vertexOffset = primitive.attributes[0].data->offset / primitive.attributes[0].data->stride;

        return prim;
    }

    static Mesh loadGltfMesh(cgltf_mesh &cmesh) {
        Mesh mesh;
        for(cgltf_primitive& primitive : std::span(cmesh.primitives, cmesh.primitives_count)) {
            mesh.primitives.push_back(loadGltfPrimitive(primitive));
        }
        return mesh;
    }

    void loadGltf(flecs::entity entity, const char *file) {

        const VkGlobals& vk = *entity.world().get<VkGlobals>();

        cgltf_options options = {};
        cgltf_data *data{};
        cgltf_result result = cgltf_parse_file(&options, file, &data);

        if (result != cgltf_result_success) {
            fprintf(stderr, "Failed to load gltf file: %s", file);
            return;
        }

        if (strstr(data->asset.generator, "gltfpack") == nullptr) {
            fprintf(stderr, "Gltf not generated by gltfpack. Run gltfpack on gltf");
            return;
        }

        result = cgltf_load_buffers(&options, data, file); // TODO load directly into buffer memory

        if (result != cgltf_result_success) {
            fprintf(stderr, "Failed to load gltf binary file for %s", file);
            return;
        }

        std::vector<VkBuffer> buffers;
        std::vector<VmaAllocation> allocations;
        buffers.reserve(data->buffers_count);

        for(auto& buffer_view : std::span(data->buffer_views, data->buffer_views_count)) {
            auto a = loadGltfBuffer(vk, buffer_view);
            buffers.push_back(a.first);
            allocations.push_back(a.second);
        }

        entity.scope([&](){
            for (auto &mesh: std::span(data->meshes, data->meshes_count)) {
                auto m = loadGltfMesh(mesh);
                entity.world().entity(mesh.name).set<Mesh>(m);
            }
        });

        cgltf_free(data);

        entity.set(Gltf{
            .buffers = buffers,
            .allocations = allocations,
        });
    }

    void handleGltfLoads(flecs::iter iter, kaki::Asset *assets) {
        for(auto i : iter) {
            loadGltf(iter.entity(i), assets[i].path);
        }

    }
}